import base64import itertoolsimport jsonimport timefrom threading import Threadimport cv2import globimport loggingimport osimport jwtimport numpy as npimport requestsimport tensorflow as tffrom http.server import HTTPServer, BaseHTTPRequestHandlerfrom typing import Tuple, Listfrom overtrack.source import RateLimitingCapturefrom overtrack.source.stream import TwitchLiveTSDownloaderfrom overtrack.source.stream import TSFrameExtractorfrom overtrack.source.video import VideoFrameExtractorfrom overtrack.game import Frame, OrderedProcessor, ConditionalProcessor, ShortCircuitProcessorfrom overtrack.game.loading_map import LoadingMapProcessorfrom overtrack.game.menu import MenuProcessorfrom overtrack.game.killfeed import KillfeedProcessorfrom overtrack.game.objective import ObjectiveProcessorfrom overtrack.game.tab import TabProcessorfrom overtrack.live_game import LiveGameStatsfrom overtrack.util import ts2ms, imageopsfrom overtrack.util.frames_cache import FramesCache, CachedFrameExtractorlogging.basicConfig(level=logging.INFO)logger = logging.getLogger(__name__)class BroadcastToTwitch:    USER_ID = os.environ['TWITCH_USER_ID']    CLIENT_ID = os.environ['TWITCH_EXTENSION_ID']    SECRET = base64.b64decode(os.environ['TWITCH_EXTENSION_SECRET'])    twitch = requests.Session()    twitch.headers.update({'Client-ID': CLIENT_ID})    UPDATE_FREQUENCY_SECONDS = 2    def __init__(self, channel: str):        self.channel = channel        self.last_update = 0    def update_stats(self, stats: LiveGameStats, timestamp: float):        if time.time() - self.last_update < self.UPDATE_FREQUENCY_SECONDS:            return        self.last_update = time.time()        if stats:            blue, red = stats.get_stats()            data = {                'timestamp': timestamp,                'teams': {                    'blue': [p.asdict() for p in blue],                    'red': [p.asdict() for p in red],                }            }        else:            data = {                'timestamp': timestamp - self.UPDATE_FREQUENCY_SECONDS,                'teams': None            }        self.broadcast(data)    def broadcast(self, message):        auth = {            'user_id': '51887413',            'exp': int(time.time() + 60),            'role': 'external',            'channel_id': self.channel,            'pubsub_perms': {                'send': [                    'broadcast'                ]            }        }        r = self.twitch.post(            'https://api.twitch.tv/extensions/message/' + self.channel,            json={                'content_type': 'application/json',                'message': json.dumps(message),                'targets': ['broadcast']            },            headers={                'Authorization': 'Bearer ' + jwt.encode(auth, self.SECRET).decode()            }        )        r.raise_for_status()class ScoreboardHTTPServer:    def _make_handler(self):        closure_binding = self        class Handler(BaseHTTPRequestHandler):            def do_GET(self):                if self.path == '/':                    path = './scoreboard/video_component.html'                else:                    path = os.path.join(os.path.dirname(__file__), 'scoreboard', os.path.normpath(self.path)[1:])                if os.path.exists(path):                    self.send_response(200)                    self.end_headers()                    if 'html' in path or 'js' in path:                        enabled = True                        with open(path, 'r') as f:                            for line in f.readlines():                                if '<!-- BEGIN: twitch -->' in line:                                    enabled = False                                if enabled:                                    self.wfile.write(line.encode())                                if '<!-- END: twitch -->' in line:                                    enabled = True                    else:                        with open(path, 'rb') as f:                            self.wfile.write(f.read())                elif self.path == '/scoreboard.json':                    if closure_binding.stats:                        code = 200                        blue, red = closure_binding.stats.get_stats()                        data = {                            'teams': {                                'blue': [p.asdict() for p in blue],                                'red': [p.asdict() for p in red],                            }                        }                    else:                        code = 404                        data = {                            'error': 'No current game'                        }                    self.send_response(code)                    self.send_header('Content-type', 'text/json')                    self.send_header('Access-Control-Allow-Origin', '*')                    self.end_headers()                    self.wfile.write(json.dumps(data).encode())                else:                    self.send_response(404)                    self.end_headers()        return Handler    def __init__(self, address='', port=8000):        self.server = HTTPServer((address, port), self._make_handler())        self.thread = Thread(target=self.server.serve_forever, daemon=True)        self.thread.start()        self.stats: LiveGameStats = None    def set_stats(self, stats: LiveGameStats):        self.stats = statsclass Display:    HERO_IMS = {        os.path.basename(p).split('.')[0]: imageops.imread(p, -1)        for p in        glob.glob("C:/Users/simon/workspace/overtrack/overtrack/overtrack/data/spectator_heroes/*.png")    }    if HERO_IMS:        HERO_IMS['soldier'] = HERO_IMS['s76']        HERO_IMS['torbjorn'] = HERO_IMS['torb']    def render_player(self, player: LiveGameStats.PlayerStats, color: Tuple[int, int, int]) -> np.ndarray:        im = np.full((50, 150, 3), fill_value=color, dtype=np.uint8)        if player.current_hero:            hero_img = cv2.resize(self.HERO_IMS[player.current_hero.split('.')[0]], (50, 50))            foreground = hero_img[:, :, :3].astype(np.float)            alpha = cv2.cvtColor(hero_img[:, :, 3], cv2.COLOR_GRAY2BGR).astype(float) / 255            background = np.full_like(foreground, color)            foreground = cv2.multiply(alpha, foreground)            background = cv2.multiply(1.0 - alpha, background)            im[:50, :50] = cv2.add(foreground, background).astype(np.uint8)        cv2.putText(im, player.name, (5, 15), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (250, 250, 250), 2)        cv2.putText(im, f'{player.kills} : {player.deaths}', (50, 35), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 0), 2)        return im    def render_stats(self, stats: Tuple[List[LiveGameStats.PlayerStats], List[LiveGameStats.PlayerStats]]) -> np.ndarray:        blue, red = stats        im = np.vstack((            np.hstack(self.render_player(p, (255, 200, 0)) for p in blue),            np.hstack(self.render_player(p, (0, 0, 255)) for p in red),        ))        return imclass Source:    def __init__(self, source: str, seek_str: str=None, fps: int=2, debug: bool=False, fix_crop=False):        self.debug = debug        self.downloading = False        self.fix_crop = fix_crop        seek = ts2ms(seek_str) / 1000 if seek_str else None        if source == 'Overwatch':            from overtrack.source.capture import OBSFrameExtractor            self.extractor = RateLimitingCapture(OBSFrameExtractor('Overwatch', debug=debug), fps=fps)        elif source.endswith('.py'):            self.extractor = CachedFrameExtractor(source)        elif source.startswith('http') or ('/' not in source and '\\' not in source):            self.tsdownloader = TwitchLiveTSDownloader(source, seek=seek)            self.extractor = TSFrameExtractor(self.tsdownloader.queue, 2, extract_fps=fps, debug_frames=debug)            self.tsdownloader.start()            self.extractor.start()            self.downloading = True        elif os.path.exists(source) and not os.path.isdir(source):            self.extractor = VideoFrameExtractor(source, extract_fps=fps, seek=seek, debug_frames=debug)        # elif os.path.exists(source) and os.path.isdir(source):        #     extractor = FolderFrameExtractor(source, debug_frames=debug)        else:            raise ValueError('Don\'t know how to read from source "%s"' % (source,))    def get(self) -> Frame:        f = self.extractor.get()        if f is None or isinstance(f, Exception):            return f        elif not self.fix_crop:            return f        else:            im = np.max(f.image, axis=2)            im = cv2.resize(im, (480, 270), interpolation=cv2.INTER_NEAREST)            blur = cv2.GaussianBlur(im, (0, 0), 2)            _, th = cv2.threshold(blur, 10, 255, cv2.THRESH_BINARY)            vsum = np.sum(th, axis=0) / (255 * 270)            tomatch = np.array([0] * 8 + [1] * (480 - 15) + [0] * 7)            match = ((vsum - tomatch) ** 2).mean(axis=0)            if match < 0.01:                im = f.image[:, 42:-42]                im = cv2.resize(im, (1920, 1080))                return Frame.create(                    im,                    f.timestamp,                    debug=True,                    **{k: v for (k, v) in f.items() if k not in ['image', 'timestamp', 'debug_image']}                )            else:                return f    def close(self) -> None:        if self.downloading:            self.tsdownloader.stop()            self.extractor.stop()            while self.extractor.queue.get(block=True) is not None:                print('.')                pass            self.tsdownloader.join()            self.extractor.join()def main(source: Source):    writer: cv2.VideoWriter    if source.debug:        fourcc = cv2.VideoWriter_fourcc(*'DIVX')        writer = cv2.VideoWriter('out.mp4', fourcc, 10, (1280, 720))    os.makedirs('frames_cache', exist_ok=True)    frames_cache_path: str    for i in itertools.count():        frames_cache_path = os.path.join('frames_cache', f'frames_{i}.py')        if not os.path.exists(frames_cache_path):            break    frames_cache = FramesCache(frames_cache_path)    # display = Display()    server = ScoreboardHTTPServer()    broadcast = BroadcastToTwitch(channel='51887413')    i = 0    teams = []    game_start_frame: Frame = None    stats: LiveGameStats = None    exit = False    for i in itertools.count():        if exit:            break        t0 = time.time()        frame = source.get()        if isinstance(frame, Exception):            raise frame        if frame is None:            break        t1 = time.time()        pipeline.process(frame)        t2 = time.time()        frame.timings.decode = (t1 - t0) * 1000        frame.timings.parse = (t2 - t1) * 1000        debug_image = frame.debug_image        frame.strip()        frames_cache.add(frame)        print(frame)        if 'main_menu' in frame or 'play_menu' in frame:            print('stats is None')            stats = None            server.set_stats(stats)        elif 'loading_map' in frame and frame.loading_map.teams:            # TODO: improve this logic            # if we are loading into a map and we have parsed teams...            # check if we have 3 frames with stable player names...            teams.append(frame.loading_map.teams)            team_names_match = len(teams) > 4 and teams[-1] == teams[-2] and teams[-2] == teams[-3]            # check that this is actually a new game...            is_new_game = game_start_frame is None or frame.timestamp - game_start_frame.timestamp > 30            # if so, then start a new stat counter            if team_names_match and is_new_game:                game_start_frame = frame                stats = LiveGameStats(frame)                server.set_stats(stats)        elif 'objective' in frame and stats is None:            # new game but no table seen            stats = LiveGameStats(None)            server.set_stats(stats)        if stats:            stats.feed(frame)        if isinstance(source.extractor, TSFrameExtractor) and source.tsdownloader.live:            broadcast.update_stats(stats, frame.timestamp)        if stats:            t3 = time.time()            # statsim = display.render_stats(stats.get_stats())            t4 = time.time()            frame.timings.stats = (t4 - t3) * 1000            # cv2.imshow('teams', statsim)            # if we are not in debug mode we need to update the UI thread ourselves            if not source.debug:                cv2.waitKey(1)        if source.debug:            im = cv2.resize(debug_image, (1280, 720))            if stats:                im[150:150 + statsim.shape[0], 10:10 + statsim.shape[1]] = statsim            writer.write(im)            cv2.imshow('frame', im)            cv2.waitKey(1)    frames_cache.close()    if source.debug:        writer.release()        cv2.destroyAllWindows()    source.close()DEBUG = True# ffmpeg -re -stream_loop -1 -i sample_1.mp4 -c:v copy -pix_fmt yuv420p -f flv rtmp://live.twitch.tv/app/<stream key># while true; do python live_scoreboard.py 2>&1 | tee ./logs/$(date '+%Y-%m-%d_%H:%M:%S').log ; echo "Crashed - waiting 15s"; sleep 15; doneif __name__ == "__main__":    with tf.Session(config=tf.ConfigProto(log_device_placement=False, device_count={'GPU': 0})) as sess:        pipeline = OrderedProcessor(            ShortCircuitProcessor(                MenuProcessor(),                LoadingMapProcessor(),                ObjectiveProcessor(save_probabilities=False),                order_defined=False            ),            TabProcessor(),            ConditionalProcessor(                OrderedProcessor(                    KillfeedProcessor(output_icon_images=False, output_name_images=False),                ),                condition=lambda f: 'objective' in f and f.objective.is_game,                lookbehind=5,                lookbehind_behaviour=any,                default_without_history=True,            ),        )        # source = Source(sys.argv[1], '0:0:0', display=False)        # source = Source('https://www.twitch.tv/videos/250290864', '0:7:00', True)        # source = Source("C:/scratch/NRG Fahzix _ Educational support-v306835334.mp4", seek_str='0:10:38', debug=DEBUG)        # source = Source('fahzix', None, debug=True)        # source = Source(None, None, True)        # source = Source('Overwatch', None, debug=False)        # source = Source('synap53', None, debug=False)        source = Source("C:/scratch/8res.mp4", seek_str='0:00:00', debug=True)        main(source)